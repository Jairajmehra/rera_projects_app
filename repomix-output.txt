This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document.
Generated by Repomix on: 2025-02-20T18:04:23.776Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/app/map/page.tsx, src/components/Map/MapContainer.tsx, src/components/FilterDrawer.tsx, src/components/MapDrawer.tsx, src/components/LocationSearch.tsx, src/components/Navbar.tsx
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
src/
  app/
    map/
      page.tsx
  components/
    Map/
      MapContainer.tsx
    FilterDrawer.tsx
    LocationSearch.tsx
    MapDrawer.tsx
    Navbar.tsx

================================================================
Files
================================================================

================
File: src/app/map/page.tsx
================
'use client'
import { useState } from "react";
import MapContainer from "@/components/Map/MapContainer";
import Navbar from "@/components/NavBar";

// Define Filters interface if you haven't already:
export interface Filters {
    bhks: string[];
    projectTypes: string[];
    locations: string[];
  }

const MapPage: React.FC = () => {
    // STEP 1: Create filters in MapPage
  const [filters, setFilters] = useState<Filters>({
    bhks: [],
    projectTypes: [],
    locations: []
  });

    return (
        <div style={{ height: '100%', width: '100%', position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, overflow: 'hidden', display: 'flex', flexDirection: 'column' }}>
            <Navbar filters={filters} onFiltersChange={setFilters}/>
            <div className="flex-1 relative">
                <MapContainer filters={filters} onFiltersChange={setFilters}/>
            </div>
        </div>
     


    )
}


export default MapPage;

================
File: src/components/Map/MapContainer.tsx
================
import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";

// Components for properties
import ResidentialPopUpCard from "../ResidentialPopUpCard";
import useResidentialProperties from "../../hooks/useResidentialProperties";
import { ResidentialProperty } from "../../services/residentialPropertyService";

import debounce from 'lodash.debounce';
import MapDrawer from "../MapDrawer";
import { parseCoordinates, getExtendedBounds } from "../../utils/Utils";
import { Filters } from "../../app/map/page";

declare global {
    interface Window {
      google: typeof google;
    }}
  
interface MapContainerProps {
      filters: Filters;
      onFiltersChange: (filters: Filters) => void; // if needed
    }


const MapContainer: React.FC<MapContainerProps> = ({ filters, onFiltersChange }) => {

    // Add a Set to track unique markers by rera number
    const markerPositionsRef = useRef(new Set<string>());

    const mapRef = useRef<HTMLDivElement>(null);
    const markersRef = useRef<google.maps.marker.AdvancedMarkerElement[]>([]);
  
    const [selectedProperty, setSelectedProperty] = useState<ResidentialProperty | null>(null);
    const [bounds, setBounds] = useState<google.maps.LatLngBounds | null>(null);
    const [mapInstance, setMapInstance] = useState<google.maps.Map | null>(null);


    // Utility function to close the pop up card
    const handleCloseCard = useCallback(() => {
        setSelectedProperty(null);
    }, []);

    function clearAllMarkers() {
        markersRef.current.forEach((marker) => (marker.map = null));
        markersRef.current = [];
        markerPositionsRef.current.clear();
      }

    /**
   * Remove markers that are outside the viewport extended by 20%.
   * Markers that lie outside the extended bounds are removed from the map.
   */
  const removeMarkersOutsideExtendedBounds = () => {
    
    if (!mapInstance) {
        console.log("mapInstance is not available");
        return;
    }
    const currentBounds = mapInstance.getBounds();
    if (!currentBounds){
        console.log("currentBounds is not available");
        return;
    } 
    // Extend viewport by 20% 
    const extensionPercentage = 0.2;
    const extendedBounds = getExtendedBounds(currentBounds, extensionPercentage);
    
    // Filter markers: remove the marker if it does not fall within extended bounds
    markersRef.current = markersRef.current.filter((marker) => {
      const markerPos = marker.position;
      if (!markerPos || !extendedBounds.contains(markerPos)) 
      {
        marker.map = null;
        markerPositionsRef.current.delete(marker.title);
        console.log('Marker removed:', marker.title);
        return false;
      }
      return true;
    });
  };

  // Fetch the projects from the API using our custom hook when the bounds change
    const { data, isLoading } = useResidentialProperties({page: 1, limit: 200, offset: 0,
        bounds: bounds? {
            north: bounds.getNorthEast().lat(),
            south: bounds.getSouthWest().lat(),
            east: bounds.getNorthEast().lng(),
            west: bounds.getSouthWest().lng(),
        } : undefined,
    });
    console.log('API Response:', data);

    // Utility function to set the new bounds waits for 500ms before setting the bounds
    const onBoundsChange = useCallback(debounce((map: google.maps.Map) => 
    {
        const newBounds = map.getBounds();
            if (newBounds) {
                console.log('Setting new bounds:', newBounds.toString());
                setBounds(newBounds);
    }}, 500), []);

    useEffect(() => {
        if (!window.google) 
        {
            console.log('Google is not available');
            const script = document.createElement('script');
            script.src = `https://maps.googleapis.com/maps/api/js?key=${process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY}&libraries=places,marker`;
            script.async = true;
            //script.defer = true;
            script.onload = () => 
            {
                initMap();
            };
            document.head.appendChild(script);
        }
        else
        {
            console.log('Google is available initializing map');
            initMap();
            return;
        }
    }, []);

    const initMap = () => 
    {
        console.log('Initializing map');
        if (!mapRef.current || !window.google){ 
            console.log('Map ref or window.google is not available');
            return;
        }
        const map = new window.google.maps.Map(mapRef.current, {
            center: { lat: 23.022938, lng: 72.530304 },
            zoom: 12,
            mapId: '4357fd779b0d90cd',
            gestureHandling: 'greedy',
        });
        map.addListener('bounds_changed', () => {
            onBoundsChange(map);
        });
        setMapInstance(map);
        console.log('Map instance set', map);
    };


        useEffect(() => 
        {
            if (!mapInstance || !bounds) return;
            removeMarkersOutsideExtendedBounds();
        }, [mapInstance, bounds]);

        const uniqueProperties = useMemo(() => 
        {
            const uniqueMap = new Map<string, ResidentialProperty>();
            data?.properties?.forEach((property) => {
              uniqueMap.set(property.airtable_id, property);
            });
            return Array.from(uniqueMap.values());
          }, [data?.properties]);

          // Apply the filters to the unique projects.
        const filteredProperties = useMemo(() => {
            console.log('Filtering Properties with filters:', filters);
            console.log('Unique Properties:', uniqueProperties);
            return uniqueProperties.filter((property) => {
            let matches = true;
            if (filters.bhks.length) {
                // Assume property.bhk is a string or an array of strings.
                const propertyBHKs = Array.isArray(property.bhk) ? property.bhk : [property.bhk];
                matches = matches && propertyBHKs.some((bhk) => filters.bhks.includes(bhk));
            }
            if (filters.projectTypes.length) {
                const types = Array.isArray(property.propertyType) ? property.propertyType : [property.propertyType];
                matches = matches && types.some((type) => filters.projectTypes.includes(type));
            }
            if (filters.locations.length) {
                const locations = Array.isArray(property.locality) ? property.locality : [property.locality];
                matches = matches && locations.some((loc) => filters.locations.includes(loc));
            }
            console.log('Property matches filters:', property.name, property.bhk,matches);
            return matches;
            });
            }, [uniqueProperties, filters]);


            const validProperties = useMemo(() => {
              console.log('Validating properties:', filteredProperties);
              const invalid: string[] = [];
              return filteredProperties.filter(property => {
                  if (!property.coordinates){
                    invalid.push(`${property.name} ${property.coordinates} (${property.airtable_id}): No coordinates`);
                    return false;
                  } 
                  const coords = parseCoordinates(property.coordinates);
                  if (!coords || isNaN(coords.lat) || isNaN(coords.lng)){
                    invalid.push(`${property.name} ${property.coordinates} (${property.airtable_id}): Invalid coordinates`);
                    return false;
                  }
                  return true;
              });
          }, [filteredProperties]);

            useEffect(() => {
                if (!mapInstance) return;
                // Clear all existing markers.
                clearAllMarkers();
                // Add new markers for each filtered project.
                validProperties.forEach((property) => {
                  const markerId = property.airtable_id;
                  const { lat, lng } = parseCoordinates(property.coordinates);

                  if (markerPositionsRef.current.has(markerId)) return;

                  const marker = new window.google.maps.marker.AdvancedMarkerElement({
                    map: mapInstance,
                    position: { lat, lng },
                    title: property.airtable_id,
                  });
                  marker.addListener("click", () => {
                    console.log("Marker clicked:", property.airtable_id);
                    setSelectedProperty(property);
                  });
                  markersRef.current.push(marker);
                  markerPositionsRef.current.add(markerId);
                });
                console.log("Markers Count after adding:", markersRef.current.length);
              }, [filteredProperties, mapInstance]);
        

    return (
        <div style={{ width: "100%", height: "100%", position: "relative" }}>
          {isLoading && <div className="loading-overlay">Loading...</div>}
          <div ref={mapRef} style={{ width: '100%', height: '100%' }} />

          {selectedProperty && (
            <ResidentialPopUpCard 
                property={selectedProperty} 
                onClose={handleCloseCard}
            />
          )}

          <MapDrawer 
            properties={filteredProperties || []} 
            filters={filters}
            onFiltersChange={onFiltersChange}
            onPropertySelect={(property) => setSelectedProperty(property)}
            />
        </div>

      );
}

export default MapContainer;

================
File: src/components/FilterDrawer.tsx
================
import React from 'react';
import { Filters } from '../app/map/page';

interface FilterDrawerProps {
  isOpen: boolean;
  onClose: () => void;
  filters: Filters;
  onFiltersChange: (filters: Filters) => void;
}

const FilterDrawer: React.FC<FilterDrawerProps> = ({ 
  isOpen, 
  onClose, 
  filters, 
  onFiltersChange 
}) => {
  return (
    <>
      {/* Backdrop */}
      <div 
        className={`fixed inset-0 bg-black/30 transition-opacity z-40 ${
          isOpen ? 'opacity-100' : 'opacity-0 pointer-events-none'
        }`}
        onClick={onClose}
      />
      
      {/* Drawer */}
      <div 
        className={`fixed right-0 top-0 bottom-0 w-[80%] max-w-[400px] bg-white 
          shadow-xl z-50 transition-transform duration-300 transform 
          ${isOpen ? 'translate-x-0' : 'translate-x-full'}`}
      >
        <div className="p-4">
          <div className="flex justify-between items-center mb-6">
            <h2 className="text-xl font-semibold">Filters</h2>
            <button onClick={onClose} className="p-2">✕</button>
          </div>
          
          {/* BHK Filter */}
          <div className="mb-6">
            <h3 className="font-semibold mb-3">BHK</h3>
            <div className="flex flex-wrap gap-2">
              {['BHK 1', 'BHK 2', 'BHK 3', 'BHK 4'].map(bhk => (
                <label key={bhk} className="flex items-center gap-2">
                  <input
                    type="checkbox"
                    checked={filters.bhks.includes(bhk)}
                    onChange={() => {
                      const bhks = filters.bhks.includes(bhk)
                        ? filters.bhks.filter(v => v !== bhk)
                        : [...filters.bhks, bhk];
                      onFiltersChange({ ...filters, bhks });
                    }}
                  />
                  {bhk}
                </label>
              ))}
            </div>
          </div>

          {/* Project Type Filter */}
          <div className="mb-6">
            <h3 className="font-semibold mb-3">Project Type</h3>
            <div className="flex flex-wrap gap-2">
              {['Residential', 'Commercial'].map(type => (
                <label key={type} className="flex items-center gap-2">
                  <input
                    type="checkbox"
                    checked={filters.projectTypes.includes(type)}
                    onChange={() => {
                      const projectTypes = filters.projectTypes.includes(type)
                        ? filters.projectTypes.filter(v => v !== type)
                        : [...filters.projectTypes, type];
                      onFiltersChange({ ...filters, projectTypes });
                    }}
                  />
                  {type}
                </label>
              ))}
            </div>
          </div>
        </div>
      </div>
    </>
  );
};

export default FilterDrawer;

================
File: src/components/LocationSearch.tsx
================
import React, { useState } from 'react';

interface LocationSearchProps {
  localities: string[];
  selectedLocalities: string[];
  onSelect: (localities: string[]) => void;
  onClose: () => void;
}

const LocationSearch: React.FC<LocationSearchProps> = ({
  localities,
  selectedLocalities,
  onSelect,
  onClose
}) => {
  const [searchText, setSearchText] = useState('');
  
  const filteredLocalities = localities.filter(loc =>
    loc.toLowerCase().includes(searchText.toLowerCase())
  );

  return (
    <div className="fixed inset-0 bg-white z-50">
      <div className="flex items-center gap-2 p-4 border-b">
        <button onClick={onClose} className="p-2">
          ←
        </button>
        <input
          type="text"
          placeholder="Search localities..."
          value={searchText}
          onChange={(e) => setSearchText(e.target.value)}
          className="flex-1 p-2 border rounded-lg"
          autoFocus
        />
      </div>
      
      <div className="overflow-auto h-[calc(100vh-80px)]">
        {filteredLocalities.map(locality => (
          <label 
            key={locality} 
            className="flex items-center gap-2 p-4 border-b"
          >
            <input
              type="checkbox"
              checked={selectedLocalities.includes(locality)}
              onChange={() => {
                const newSelection = selectedLocalities.includes(locality)
                  ? selectedLocalities.filter(l => l !== locality)
                  : [...selectedLocalities, locality];
                onSelect(newSelection);
              }}
            />
            {locality}
          </label>
        ))}
      </div>
    </div>
  );
};

export default LocationSearch;

================
File: src/components/MapDrawer.tsx
================
import React, { useState } from 'react';
import ResidentialPropertyCard from './ResidentialPropertyCard';
import useViewport from './useViewport';
import { Filters } from '../app/map/page';
import { ResidentialProperty } from '../services/residentialPropertyService';

export type DrawerState = 'collapsed' | 'partial' | 'full';

interface MapDrawerProps {
    properties: ResidentialProperty[];
    onPropertySelect: (property: ResidentialProperty) => void;
    filters: Filters;
    onFiltersChange: (filters: Filters) => void;
}

const MapDrawer: React.FC<MapDrawerProps> = ({ properties, onPropertySelect, filters, onFiltersChange }) => {

    const [drawerState, setDrawerState] = useState<DrawerState>('collapsed');
    const isMobile = useViewport();

    const toggleDrawerState = () => {
        // Cycle through states: collapsed -> partial -> full -> collapsed...
        if (isMobile) {
            setDrawerState(prev => {
                if (prev === 'collapsed') return 'partial';
                if (prev === 'partial') return 'full';
                return 'collapsed';
            });
        }
    };

      const drawerStyles = isMobile
      ? {
          height: drawerState === 'collapsed' ? '40px' 
                 : drawerState === 'partial' ? '40%' 
                 : '90%',
          transition: 'height 0.3s',
          width: '100%'
        }
      : {
          height: '100%',
          width: '400px',
          right: 0,
          top: 0
        };

    return (
        <div
          style={drawerStyles}
          className={`fixed bg-white shadow-lg overflow-hidden z-20 ${
            isMobile ? "bottom-0 left-0 right-0" : "top-0"
          }`}
        >
          {isMobile && (
            <div className="p-2 border-b cursor-pointer" onClick={toggleDrawerState}>
              <div className="w-12 h-1 bg-gray-400 rounded mx-auto"></div>
            </div>
          )}
    
          {/* Project list */}
          {(!isMobile || drawerState !== "collapsed") && (
            <div className="p-4 overflow-auto h-full">
              <div className="space-y-4">
                {properties.map((property) => (
                  <ResidentialPropertyCard
                    key={property.airtable_id}
                    property={property}
                    onClick={() => onPropertySelect(property)}
                  />
                ))}
                {properties.length === 0 && <div>No properties match these filters.</div>}
              </div>
            </div>
          )}
        </div>
      );
};

export default MapDrawer;

================
File: src/components/Navbar.tsx
================
'use client';

import { useState } from 'react';
import Link from 'next/link';
import { Filters } from '../app/map/page';
import useLocalities from '../hooks/useLocalities';
import MultiSelectLocalities from './MultiSelectLocalities';
import FilterDrawer from './FilterDrawer';
import LocationSearch from './LocationSearch';
import useViewport from './useViewport';

interface NavbarProps {
  filters: Filters;
  onFiltersChange: (filters: Filters) => void;
}

export default function Navbar({ filters, onFiltersChange }: NavbarProps) {
  
  const { data: allLocalities = [], isLoading } = useLocalities();
  const isMobile = useViewport(768);
  const availableBHKs = ['BHK 1', 'BHK 2', 'BHK 3', 'BHK 4'];
  const availableProjectTypes = ['Residential', 'Commercial'];
  const [isFilterDrawerOpen, setIsFilterDrawerOpen] = useState(false);
  const [isLocationSearchOpen, setIsLocationSearchOpen] = useState(false);

  const handleLocalityChange = (newLocalities: string[]) => {
    onFiltersChange({
      ...filters,
      locations: newLocalities
    });
  };

  if (isLoading) return <div>Loading localities...</div>;

  

    return (
      <>
        <nav className="relative z-50 bg-white shadow-lg p-4">
          <div className="max-w-7xl mx-auto flex items-center justify-between gap-4">
            {/* Location Search Button */}
            <button
              onClick={() => setIsLocationSearchOpen(true)}
              className="flex-1 text-left p-2 border rounded-lg text-gray-500"
            >
              {filters.locations.length 
                ? `${filters.locations.length} locations selected`
                : 'Search locations...'}
            </button>
    
            {/* Filter Icon (Mobile Only) */}
            {isMobile && (
              <button 
                onClick={() => setIsFilterDrawerOpen(true)}
                className="p-2 rounded-full hover:bg-gray-100 active:bg-gray-200"
                aria-label="Open filters"
              >
                <svg 
                  width="24" 
                  height="24" 
                  viewBox="0 0 24 24" 
                  fill="none" 
                  stroke="currentColor" 
                  strokeWidth="2"
                  className="text-gray-700"
                >
                  <path d="M3 6h18M3 12h18M3 18h18" strokeLinecap="round" />
                </svg>
              </button>
            )}
    
            {/* Desktop Filters */}
            {!isMobile && (
              <div className="flex gap-4">
                {/* Your existing desktop filters */}
              </div>
            )}
          </div>
        </nav>
    
        {/* Add these components */}
        <FilterDrawer
          isOpen={isFilterDrawerOpen}
          onClose={() => setIsFilterDrawerOpen(false)}
          filters={filters}
          onFiltersChange={onFiltersChange}
        />
    
        {isLocationSearchOpen && (
          <LocationSearch
            localities={allLocalities}
            selectedLocalities={filters.locations}
            onSelect={(locations) => {
              onFiltersChange({ ...filters, locations });
              setIsLocationSearchOpen(false);
            }}
            onClose={() => setIsLocationSearchOpen(false)}
          />
        )}
      </>
    );

    // <nav className="bg-white shadow-lg p-4">
    //     <div className="max-w-7xl mx-auto flex items-center justify-between gap-4">
    //       {/* Location Search Button */}
    //       <button
    //         onClick={() => setIsLocationSearchOpen(true)}
    //         className="flex-1 text-left p-2 border rounded-lg text-gray-500"
    //       >
    //         San Francisco CA homes
    //       </button>

    //       {/* Filter Icon (Mobile Only) */}
    //       {isMobile && (
    //         <button 
    //           onClick={() => setIsFilterDrawerOpen(true)}
    //           className="p-2 rounded-full hover:bg-gray-100 active:bg-gray-200"
    //           aria-label="Open filters"
    //         >
    //           <svg 
    //             width="24" 
    //             height="24" 
    //             viewBox="0 0 24 24" 
    //             fill="none" 
    //             stroke="currentColor" 
    //             strokeWidth="2"
    //             className="text-gray-700"
    //           >
    //             <path d="M3 6h18M3 12h18M3 18h18" strokeLinecap="round" />
    //           </svg>
    //         </button>
    //       )}
          
    //       {/* ... rest of your code ... */}
    //     </div>
    //   </nav>
    // <nav className="bg-white shadow-lg p-4">
    //   <div className="max-w-7xl mx-auto">
    //     {/* STEP 1: Remove brand or logo references */}
    //     {/* STEP 2: Render filters in navbar */}
        
    //     <div className="flex flex-wrap items-center">
    //       {/* BHK Filter */}
    //       <div className="mr-8">
    //         <span className="font-semibold">BHK: </span>
    //         {availableBHKs.map(bhk => (
    //           <label key={bhk} className="ml-2">
    //             <input
    //               type="checkbox"
    //               checked={filters.bhks.includes(bhk)}
    //               onChange={() => {
    //                 const bhks = filters.bhks.includes(bhk)
    //                   ? filters.bhks.filter(v => v !== bhk)
    //                   : [...filters.bhks, bhk];
    //                 onFiltersChange({ ...filters, bhks });
    //               }}
    //             />
    //             {" "}{bhk}
    //           </label>
    //         ))}
    //       </div>

    //       {/* Project Type Filter */}
    //       <div className="mr-8">
    //         <span className="font-semibold">Project Type: </span>
    //         {availableProjectTypes.map(pt => (
    //           <label key={pt} className="ml-2">
    //             <input
    //               type="checkbox"
    //               checked={filters.projectTypes.includes(pt)}
    //               onChange={() => {
    //                 const projectTypes = filters.projectTypes.includes(pt)
    //                   ? filters.projectTypes.filter(v => v !== pt)
    //                   : [...filters.projectTypes, pt];
    //                 onFiltersChange({ ...filters, projectTypes });
    //               }}
    //             />
    //             {" "}{pt}
    //           </label>
    //         ))}
    //       </div>

    //       {/* Location Filter */}
    //       <div>
    //             <span>Locations:</span>
    //             <MultiSelectLocalities
    //             localities={allLocalities}
    //             selectedLocalities={filters.locations}
    //             onChange={handleLocalityChange}/>
    //       </div>
    //     </div>
    //   </div>
    // </nav>
  
}



================================================================
End of Codebase
================================================================
